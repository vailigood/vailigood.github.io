(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{364:function(t,s,a){"use strict";a.r(s);var i=a(42),h=Object(i.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"this"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#this"}},[t._v("#")]),t._v(" this")]),t._v(" "),a("blockquote",[a("p",[t._v("首先要说明的是，this 运行机制与参、函数的作用域机制无关。两者只有且只有指向顶层的时候是同一个对象 window(global)。")])]),t._v(" "),a("h2",{attrs:{id:"this-是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#this-是什么"}},[t._v("#")]),t._v(" this 是什么")]),t._v(" "),a("h2",{attrs:{id:"this-的缺陷"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#this-的缺陷"}},[t._v("#")]),t._v(" this 的缺陷")]),t._v(" "),a("h3",{attrs:{id:"嵌套函数中的-this-不会从外层函数中继承"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#嵌套函数中的-this-不会从外层函数中继承"}},[t._v("#")]),t._v(" 嵌套函数中的 this 不会从外层函数中继承")]),t._v(" "),a("ol",[a("li",[t._v("将 this 保存为一个变量，如 that，利用变量的作用域机制传递给嵌套函数（闭包或函数参数）")]),t._v(" "),a("li",[t._v("继续使用 this，但是把普通函数改为箭头函数，因为箭头函数没有自己的执行上下文，所以它会结成调用函数的 this")])]),t._v(" "),a("h3",{attrs:{id:"普通函数中的-this-默认指向全局对象-window"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#普通函数中的-this-默认指向全局对象-window"}},[t._v("#")]),t._v(" 普通函数中的 this 默认指向全局对象 window")]),t._v(" "),a("p",[t._v("通过"),a("strong",[t._v("严格模式")]),t._v("来防止普通函数中 this 指向 window")])])}),[],!1,null,null,null);s.default=h.exports}}]);